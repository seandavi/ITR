---
title: "Matrices"
output: html_document
---

A _matrix_ is a rectangular collection of the same data type. It can be viewed as a collection
of column vectors all of the same length and the same type (i.e. numeric, character or logical) OR a collection of row vectors, again all of the same type and length. A _data.frame_ is *also* a rectangular array. All of the columns must be the same length, but they may be of *different* types. The rows and columns of a matrix or data frame can be given names. However these are implemented differently in R; many operations will work for one but not both, often a source of confusion.

In this section, we will be working with matrices. The _data.frame_ will be dealt with elsewhere.

# Matrices

## Creating a matrix

There are many ways to create a matrix in R. One of the simplest is to use the `matrix()` function. In the code below, we'll create a matrix from a vector from 1:16.

```{r}
mat1 <- matrix(1:16,nrow=4)
mat1
```

The same is possible, but specifying that the matrix be "filled" by row.

```{r}
mat1 <- matrix(1:16,nrow=4,byrow = TRUE)
mat1
```

Notice the subtle difference in the order that the numbers go into the matrix.



We can also build a matrix from parts by "binding" vectors together:

```{r}
x <- 1:10 
y <- rnorm(10)
```

Each of the vectors above is of length 10 and both are "numeric", so we can make
them into a matrix. Using `rbind` binds rows (**r**) into a matrix.

```{r}
mat <- rbind(x,y)
mat
```

The alternative to `rbind` is `cbind` that binds columns. 

```{r}
mat <- cbind(x,y)
mat
```

Inspecting the names associated with rows and columns is often useful, particularly if the names have human meaning. 

```{r}
rownames(mat)
colnames(mat)
```

We can also change the names of the matrix by assigning _valid_ names to the 
columns or rows.

```{r}
colnames(mat) = c('apples','oranges')
colnames(mat)
mat
```



Matrices have dimensions.

```{r}
dim(mat)
nrow(mat)
ncol(mat)
```

## Accessing elements of a matrix

Indexing for matrices works as for vectors except that we now need to
include both the row and column (in that order). We can access elements 
of a matrix using the square bracket [ indexing method. Elements can be 
accessed as `var[r, c]`. Here, `r` and `c` are vectors describing the elements
of the matrix to select.

```{r}
# The 2nd element of the 1st row of mat
mat[1,2]
# The first ROW of mat
mat[1,]
# The first COLUMN of mat
mat[,1]
# and all elements of mat that are > 4; note no comma
mat[mat>4]
## [1]  5  6  7  8  9 10
```

Note that in the last case, there is no ",", so R treats the matrix as a long 
vector (length=20). This is convenient, sometimes, but it can also be a source 
of error, as some code may "work" but be doing something unexpected.

We can also use indexing to exclude a row or column by prefixing the selection
with a `-` sign.

```{r}
mat[,-1]       # remove first column
mat[-c(1:5),]  # remove first five rows
```

## Changing values in a matrix

We can create a matrix filled with random values drawn from a normal
distribution.

```{r}
m = matrix(rnorm(20),nrow=10)
summary(m)
```


# multiply all values in the matrix by 20
m = m*20
# and add 100 to the first column of m
m[,1] = m[,1] + 100
# summarize m
summary(m)
```

- Transpose
- apply
- colSums
- rowSums
- 
